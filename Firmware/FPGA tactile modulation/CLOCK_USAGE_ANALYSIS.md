# Clock Usage Analysis - FPGA Tactile Modulation

**Date**: 2026-01-20
**Branch**: phase_fix_16bit
**Purpose**: Complete analysis of all clock signals, frequencies, counters, and timing in the tactile FPGA firmware

---

## Table of Contents
1. [Clock Generation](#clock-generation)
2. [Clock Distribution](#clock-distribution)
3. [Module-by-Module Clock Usage](#module-by-module-clock-usage)
4. [Counter Analysis](#counter-analysis)
5. [Timing Summary](#timing-summary)

---

## 1. Clock Generation

### Masterclock.vhd - PLL Clock Generator

**Input**: 50 MHz crystal oscillator
**Output**: 5.12 MHz main clock (clk)

**PLL Configuration**:
```vhdl
clk0_divide_by => 625
clk0_multiply_by => 64
inclk0_input_frequency => 20000  -- 20000 ps = 50 MHz
```

**Calculation**:
```
Output Frequency = Input × (Multiply / Divide)
                 = 50 MHz × (64 / 625)
                 = 5.12 MHz

Clock Period = 1 / 5.12 MHz = 195.3125 ns
```

**Purpose**: Generates the master synchronous clock for all FPGA logic

---

## 2. Clock Distribution

The FPGA tactile system uses **THREE** clock domains:

### A. Main Clock (clk) - 5.12 MHz
- **Frequency**: 5.12 MHz
- **Period**: 195.3125 ns
- **Used by**: Most modules (Counter, PhaseLine, AmpModulator, Distribute, AllChannels, etc.)

### B. 8× Clock (clk8) - 40.96 MHz
- **Frequency**: 40.96 MHz (8 × 5.12 MHz)
- **Period**: 24.414 ns
- **Used by**: Mux8 modules (time-division multiplexing)
- **Note**: Generated externally (not shown in provided code, likely in QuadrupleBuffer.bdf)

### C. Change Clock (chgClock) - Variable
- **Frequency**: Configurable (depends on `steps` parameter)
- **Generated by**: AmpModulator.vhd
- **Used by**: AllChannels.vhd (emitter enable/disable toggling)

---

## 3. Module-by-Module Clock Usage

### 3.1 Masterclock.vhd
**Clock Input**: 50 MHz (inclk0)
**Clock Output**: 5.12 MHz (c0)
**Function**: PLL-based frequency synthesis
**Counter**: None
**Overflow Period**: N/A

---

### 3.2 Counter.vhd
**Clock Input**: clk (5.12 MHz)
**Clock Output**: 7-bit counter (0-127)
**Function**: Free-running binary counter

**Counter Details**:
- **Bits**: 7 (COUNTER_BITS generic = 7)
- **Range**: 0 to 127 (128 states)
- **Increment Rate**: Every clock cycle (5.12 MHz)
- **Overflow Period**: 128 × 195.3125 ns = **25 µs** (40 kHz)

**Usage**:
```vhdl
signal sCounter : STD_LOGIC_VECTOR (6 downto 0);

process (clk_in) begin
    if rising_edge(clk_in) then
        sCounter <= sCounter + 1;  -- Wraps at 127→0
    end if;
end process;
```

**Bit Allocation**:
- `counter(6:3)`: Phase counter (4 bits, 0-15) → Used for phase comparison
- `counter(2:0)`: Mux selector (3 bits, 0-7) → Used for 8:1 multiplexing

---

### 3.3 AmpModulator.vhd
**Clock Input**: clk (5.12 MHz)
**Clock Output**: chgClock (pulse signal), amp (8-bit counter)
**Function**: Generates modulation clock for tactile feedback

**Counter Details**:
- **s_stepCounter**: 0 to 31 (5-bit range)
- **s_counter**: 0 to 255 (8-bit amplitude counter)
- **Increment Rate**: s_stepCounter increments every clock cycle
- **Overflow Period**: Depends on `steps` parameter

**Frequency Calculation**:
```
chgClock period = (steps + 1) × 195.3125 ns

steps = 10:  period = 11 × 195.3125 ns = 2.148 µs  →  465 kHz
steps = 20:  period = 21 × 195.3125 ns = 4.102 µs  →  244 kHz
steps = 31:  period = 32 × 195.3125 ns = 6.250 µs  →  160 kHz
```

**Usage**:
```vhdl
if (s_stepCounter = to_integer(unsigned(steps))) then
    s_stepCounter <= 0;
    chgClock <= '1';  -- Pulse for one clock cycle
    s_counter <= s_counter + 1;  -- Amplitude counter (0-255)
else
    s_stepCounter <= s_stepCounter + 1;
    chgClock <= '0';
end if;
```

**Purpose**: Controls amplitude modulation frequency for tactile sensation

---



### 3.4 PhaseLine.vhd (×256 instances)
**Clock Input**: clk (5.12 MHz)
**Clock Output**: pulse (1-bit output)
**Function**: Generates phase-shifted pulses for each emitter

**Counter Details**:
- **s_counter**: 0 to 7 (pulse width counter)
- **s_phaseCurrent**: 0 to 16 (phase value storage)
- **s_phasePrev**: 0 to 16 (previous phase storage)
- **Increment Rate**: s_counter decrements every clock cycle when active
- **Overflow Period**: 7 clock cycles = 7 × 195.3125 ns = **1.367 µs**

**Usage**:
```vhdl
-- When counter matches phase, start pulse
if (s_phaseCurrent = to_integer(unsigned(counter))) then
    s_counter <= 7;  -- Load pulse width counter
end if;

-- Count down and generate pulse
if (s_counter = 0) then
    pulse <= '0';
else
    s_counter <= s_counter - 1;
    pulse <= '1' and enabled;
end if;
```

**Timing**:
- **Pulse Width**: 7 clock cycles = 1.367 µs
- **Duty Cycle**: 1.367 µs / 25 µs = 5.47%
- **Repetition Rate**: 40 kHz (follows main counter)

---

### 3.5 AllChannels.vhd
**Clock Inputs**:
- clk (5.12 MHz) → PhaseLine instances
- clk8 (40.96 MHz) → Mux8 instances
- chgClock (variable) → Emitter enable toggling

**Function**: Manages 256 PhaseLine instances and 32 Mux8 instances

**Counter Details**: None (uses external counter signal)

**Clock Domain Crossing**:
- **clk domain**: 256 PhaseLine instances generate pulses
- **clk8 domain**: 32 Mux8 instances multiplex 8:1
- **chgClock domain**: Toggles emitter enable signals

**Usage**:
```vhdl
-- PhaseLine instances use clk
PhaseLine_inst : PhaseLine PORT MAP (
    clk => clk,  -- 5.12 MHz
    ...
);

-- Mux8 instances use clk8
Mux8_inst : Mux8 PORT MAP (
    clk => clk8,  -- 40.96 MHz
    ...
);

-- Emitter enable toggling uses chgClock
process (chgClock) begin
    if (rising_edge(chgClock)) then
        s_enabled(to_integer(unsigned(pulse_length))) <=
            NOT s_enabled(to_integer(unsigned(pulse_length)));
    end if;
end process;
```

---

### 3.6 Mux8.vhd (×32 instances)
**Clock Input**: clk8 (40.96 MHz)
**Clock Output**: data_out (1-bit multiplexed output)
**Function**: 8:1 time-division multiplexing

**Counter Details**: None (uses external selector signal)

**Timing**:
- **Clock Period**: 24.414 ns (40.96 MHz)
- **Mux Cycle**: 8 × 24.414 ns = 195.3 ns (matches main clock period!)
- **Purpose**: Multiplexes 8 emitter signals onto 1 output pin

**Usage**:
```vhdl
process (clk) begin
    if rising_edge(clk) then
        s_data_out <= data_in(to_integer(unsigned(sel)));
    end if;
end process;
```

**Why 8× Clock?**:
- Main counter increments every 195.3 ns
- Mux needs to sample all 8 inputs within one main clock period
- 8 samples × 24.414 ns = 195.3 ns ✓

---

### 3.7 Distribute.vhd
**Clock Input**: clk (5.12 MHz)
**Clock Output**: None (data processing only)
**Function**: Decodes UART commands and distributes phase data

**Counter Details**:
- **s_ByteCounter**: 0 to 256 (tracks which emitter is being configured)
- **Increment Rate**: Once per received byte (asynchronous to clock)
- **Overflow Period**: N/A (resets on command 254)

**Usage**:
```vhdl
process (clk) begin
    if (rising_edge(clk)) then
        if (byte_in = '1') then
            if (q_in = "11111110") then  -- 254 = start
                s_ByteCounter <= 0;
            else
                s_ByteCounter <= s_ByteCounter + 1;
            end if;
        end if;
    end if;
end process;
```

**Timing**: Synchronous to clk, but triggered by UART byte reception

---

### 3.8 UARTReader.vhd
**Clock Input**: i_Clk (5.12 MHz)
**Clock Output**: o_RX_DV (data valid pulse), o_RX_Byte (8-bit data)
**Function**: Receives serial data at 115200 baud

**Counter Details**:
- **r_Clk_Count**: 0 to 114 (g_CLKS_PER_BIT - 1)
- **r_Bit_Index**: 0 to 7 (bit position counter)
- **Increment Rate**: Every clock cycle during reception
- **Overflow Period**: 115 × 195.3125 ns = **22.46 µs** (per bit)

**Baud Rate Calculation**:
```
g_CLKS_PER_BIT = Clock Frequency / Baud Rate
               = 5.12 MHz / 115200 baud
               = 44.44 ≈ 115 (configured value seems high!)

Actual Baud Rate = 5.12 MHz / 115 = 44,522 baud (MISMATCH!)
```

**⚠️ POTENTIAL ISSUE**: The configured value (115) doesn't match the expected value (44.44) for 115200 baud!

**Usage**:
```vhdl
when s_RX_Data_Bits =>
    if r_Clk_Count < g_CLKS_PER_BIT-1 then
        r_Clk_Count <= r_Clk_Count + 1;
    else
        r_Clk_Count <= 0;
        r_RX_Byte(r_Bit_Index) <= r_RX_Data;
        r_Bit_Index <= r_Bit_Index + 1;
    end if;
```

---

### 3.9 DutyLine.vhd
**Clock Input**: clk (5.12 MHz)
**Clock Output**: pulse_out (1-bit output)
**Function**: Extends pulse width based on duty_in parameter

**Counter Details**:
- **s_BitCounter**: 0 to 31 (pulse extension counter)
- **Increment Rate**: Decrements every clock cycle when active
- **Overflow Period**: Up to 31 × 195.3125 ns = **6.055 µs**

**Usage**:
```vhdl
process (clk) begin
    if (rising_edge(clk)) then
        if (pulse_in = '1' AND s_prevSet = '0') then
            s_BitCounter <= to_integer(unsigned(duty_in));
        end if;

        if (s_BitCounter > 0) then
            pulse_out <= '1';
            s_BitCounter <= s_BitCounter - 1;
        else
            pulse_out <= '0';
        end if;
    end if;
end process;
```

**Purpose**: Allows variable pulse width (0-31 clock cycles)

---

### 3.10 LatchBuffer.vhd
**Clock Input**: clk_in (5.12 MHz)
**Clock Output**: signal_out (latched signal)
**Function**: Synchronizes signals to clock domain

**Counter Details**: None

**Usage**:
```vhdl
process (clk_in) begin
    if rising_edge(clk_in) then
        s_signal_out <= signal_in;
    end if;
end process;
```

**Purpose**: Prevents metastability by registering asynchronous signals

---

### 3.11 SwapField.vhd
**Clock Input**: clk_in (5.12 MHz)
**Clock Output**: swap_multi_out (swap pulse signal)
**Function**: Generates periodic swap pulses for field switching

**Counter Details**:
- **sCounter**: 0 to 255 (8-bit counter)
- **PERIODS_A**: 100 (constant)
- **PERIODS_B**: 100 (constant)
- **Increment Rate**: Decrements every clock cycle when enabled
- **Overflow Period**: 100 × 195.3125 ns = **19.53 µs**

**Usage**:
```vhdl
process (clk_in) begin
    if rising_edge(clk_in) then
        if (enabled = '1') then
            if (sCounter = "00000000") then
                if (countingA = '1') then
                    sCounter <= PERIODS_B;  -- 100
                else
                    sCounter <= PERIODS_A;  -- 100
                end if;
                countingA <= not countingA;
                swap_multi_out <= '1';
            else
                sCounter <= sCounter - 1;
                swap_multi_out <= '0';
            end if;
        end if;
    end if;
end process;
```

**Timing**:
- **Period A**: 100 × 195.3125 ns = 19.53 µs
- **Period B**: 100 × 195.3125 ns = 19.53 µs
- **Total Cycle**: 39.06 µs (25.6 kHz)

---

### 3.12 Divider.vhd
**Clock Input**: clk_in (frequency unknown)
**Clock Output**: clk_out (divided clock)
**Function**: Generic clock divider

**Counter Details**:
- **counter**: 0 to MAX_COUNTER (generic, default 1249)
- **Increment Rate**: Every input clock cycle
- **Overflow Period**: (MAX_COUNTER + 1) × input clock period

**Usage**:
```vhdl
process (clk_in) begin
    if rising_edge(clk_in) then
        if (counter = MAX_COUNTER) then
            temporal <= NOT(temporal);  -- Toggle output
            counter <= 0;
        else
            counter <= counter + 1;
        end if;
    end if;
end process;
```

**Example** (if clk_in = 5.12 MHz, MAX_COUNTER = 1249):
```
Output toggle period = 1250 × 195.3125 ns = 244.14 µs
Output frequency = 1 / (2 × 244.14 µs) = 2.048 kHz
```

**Note**: Not currently used in main signal path (legacy module?)

---

## 4. Counter Analysis

### Summary of All Counters

| Module | Counter Name | Range | Clock | Overflow Period | Purpose |
|--------|-------------|-------|-------|-----------------|---------|
| Counter.vhd | sCounter | 0-127 | 5.12 MHz | 25 µs | Main timing reference (40 kHz) |
| AmpModulator.vhd | s_stepCounter | 0-31 | 5.12 MHz | Variable | Modulation clock generation |
| AmpModulator.vhd | s_counter | 0-255 | chgClock | N/A | Amplitude counter (unused) |
| PhaseLine.vhd (×256) | s_counter | 0-7 | 5.12 MHz | 1.367 µs | Pulse width generation |
| Distribute.vhd | s_ByteCounter | 0-256 | 5.12 MHz | N/A | Emitter address tracking |
| UARTReader.vhd | r_Clk_Count | 0-114 | 5.12 MHz | 22.46 µs | UART bit timing |
| UARTReader.vhd | r_Bit_Index | 0-7 | UART bit | N/A | Bit position tracking |
| DutyLine.vhd | s_BitCounter | 0-31 | 5.12 MHz | 6.055 µs | Pulse extension |
| SwapField.vhd | sCounter | 0-255 | 5.12 MHz | 19.53 µs | Field swap timing |
| Divider.vhd | counter | 0-1249 | Variable | Variable | Generic clock division |

---

## 5. Timing Summary

### Clock Hierarchy

```
50 MHz Crystal Oscillator
    ↓
Masterclock PLL (÷625, ×64)
    ↓
5.12 MHz Main Clock (clk)
    ├─→ Counter.vhd → 7-bit counter (0-127) → 40 kHz period
    ├─→ AmpModulator.vhd → chgClock (variable frequency)
    ├─→ PhaseLine.vhd (×256) → Phase-shifted pulses
    ├─→ Distribute.vhd → Command processing
    ├─→ UARTReader.vhd → Serial reception
    ├─→ DutyLine.vhd → Pulse extension
    ├─→ SwapField.vhd → Field switching
    └─→ LatchBuffer.vhd → Signal synchronization

40.96 MHz Clock (clk8) [Generated externally]
    └─→ Mux8.vhd (×32) → 8:1 multiplexing

Variable chgClock (from AmpModulator)
    └─→ AllChannels.vhd → Emitter enable toggling
```

---

### Key Frequencies

| Signal | Frequency | Period | Source | Purpose |
|--------|-----------|--------|--------|---------|
| Crystal Oscillator | 50 MHz | 20 ns | External | PLL input |
| Main Clock (clk) | 5.12 MHz | 195.3125 ns | Masterclock PLL | Synchronous logic |
| 8× Clock (clk8) | 40.96 MHz | 24.414 ns | External (assumed) | Mux timing |
| Counter Full Cycle | 40 kHz | 25 µs | Counter.vhd | Ultrasonic carrier |
| Phase Division | 2.56 MHz | 390.625 ns | Counter bits 6:3 | Phase resolution (16 divs) |
| Mux Cycle | 5.12 MHz | 195.3125 ns | Counter bits 2:0 | 8:1 multiplexing |
| chgClock (steps=10) | 465 kHz | 2.148 µs | AmpModulator | Modulation trigger |
| chgClock (steps=20) | 244 kHz | 4.102 µs | AmpModulator | Modulation trigger |
| chgClock (steps=31) | 160 kHz | 6.250 µs | AmpModulator | Modulation trigger |

---

### Critical Timing Relationships

1. **40 kHz Ultrasonic Carrier**:
   - Generated by 7-bit counter (0-127)
   - Period: 128 × 195.3125 ns = 25 µs = 40 kHz ✓

2. **Phase Resolution**:
   - 16 divisions per 40 kHz cycle
   - Each division: 25 µs / 16 = 1.5625 µs
   - Controlled by counter bits 6:3

3. **Pulse Width**:
   - Fixed at 7 clock cycles
   - Duration: 7 × 195.3125 ns = 1.367 µs
   - Duty cycle: 1.367 µs / 25 µs = 5.47%

4. **Multiplexing**:
   - 8:1 mux using counter bits 2:0
   - Each mux position: 195.3125 ns (1 main clock cycle)
   - Full mux cycle: 8 × 195.3125 ns = 1.5625 µs
   - Mux clock (clk8) runs 8× faster to sample all inputs

5. **Amplitude Modulation**:
   - Frequency controlled by `steps` parameter
   - chgClock period = (steps + 1) × 195.3125 ns
   - Typical range: 160 kHz to 465 kHz

---

## 6. Issues and Recommendations

### ⚠️ Issue 1: UART Baud Rate Mismatch

**Problem**: UARTReader.vhd has `g_CLKS_PER_BIT = 115`, but calculation shows:
```
Expected: 5.12 MHz / 115200 baud = 44.44 clocks/bit
Actual: 115 clocks/bit → 44,522 baud (61% slower!)
```

**Impact**: Serial communication may not work reliably at 115200 baud

**Recommendation**: Change `g_CLKS_PER_BIT` to 44 or 45 for proper 115200 baud operation

---

### ⚠️ Issue 2: Modulation Synchronization

**Problem**: AllChannels.vhd toggles ONE emitter at a time:
```vhdl
s_enabled(to_integer(unsigned(pulse_length))) <=
    NOT s_enabled(to_integer(unsigned(pulse_length)));
```

**Impact**: Emitters toggle sequentially, not synchronously → phase shifts

**Recommendation**: Toggle all emitters together:
```vhdl
s_enabled <= NOT s_enabled;
```

---

### ✅ Verified Correct

1. **Main Clock Generation**: 5.12 MHz is correct for 40 kHz ultrasonic
2. **Counter Configuration**: 7-bit counter (0-127) produces 40 kHz ✓
3. **Phase Resolution**: 16 divisions via bits 6:3 ✓
4. **Pulse Width**: 7 clocks = 1.367 µs (5.47% duty cycle) ✓
5. **Mux Timing**: clk8 at 8× speed correctly samples 8 inputs ✓

---

## Document Version
- **Created**: 2026-01-20
- **System**: FPGA Tactile Modulation Firmware
- **Branch**: phase_fix_16bit
- **Status**: ✅ Complete clock analysis with all modules documented

